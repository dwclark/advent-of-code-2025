(declaim (optimize (debug 3)))

(defpackage :day-09
  (:use #:cl)
  (:import-from :utils #:read-day-file)
  (:import-from :alexandria #:map-combinations #:ensure-gethash)
  (:export #:part-1 #:part-2))

(in-package :day-09)

(defstruct (point (:conc-name nil))
  (x 0 :type fixnum)
  (y 0 :type fixnum))

(defun area (p0 p1)
  (* (1+ (abs (- (x p0) (x p1))))
     (1+ (abs (- (y p0) (y p1))))))

(defparameter *reds* nil)
(defparameter *greens* nil)
(defparameter *sorted-red-pairs* nil)

(defun loaded-data (day proc)
  (flet ((transform (s)
	   (let ((lst (read-from-string (concatenate 'string "(" (substitute #\Space #\, s) ")"))))
	     (make-point :x (car lst) :y (cadr lst))))
	 (complete-line (p0 p1)
	   (if (= (x p0) (x p1))
	       (loop with min-y = (1+ (min (y p0) (y p1)))
		     for new-y from min-y below (max (y p0) (y p1))
		     collecting (make-point :x (x p0) :y new-y))
	       (loop with min-x = (1+ (min (x p0) (x p1)))
		     for new-x from min-x below (max (x p0) (x p1))
		     collecting (make-point :x new-x :y (y p0)))))
	 (sorted-red-pairs ()
	   (let ((vec (make-array 0 :adjustable t :fill-pointer 0)))
	     (map-combinations #'(lambda (lst)
				   (vector-push-extend (cons (area (first lst) (second lst)) lst) vec))
			       *reds* :length 2)
	     (sort vec #'> :key #'car))))
    
    (let* ((*reds* (mapcar #'transform (read-day-file day)))
	   (*greens* (loop for sub on (append *reds* (list (first *reds*)))
			   when (second sub)
			     nconcing (complete-line (first sub) (second sub)) into ret
			   end
			   finally (return ret)))
	   (*sorted-red-pairs* (sorted-red-pairs)))
      (funcall proc))))

(defun part-1 ()
  (loaded-data "09" #'(lambda ()
			(car (aref *sorted-red-pairs* 0)))))

(defun binary-search (ary locate)
  (loop with low = 0
	with high = (1- (length ary))
	while (<= low high)
	do (let* ((mid (ash (+ low high) -1))
		  (mid-val (aref ary mid)))
	     (cond ((< mid-val locate)
		    (setf low (1+ mid)))
		   ((< locate mid-val)
		    (setf high (1- mid)))
		   (t (return mid))))
	finally (return (- (+ low 1)))))

(defun solve-2 ()
  (let ((y-lists (make-hash-table))
	(x-lists (make-hash-table)))
    (loop for p in (append *reds* *greens*)
	  do (vector-push-extend (y p) (ensure-gethash (x p) y-lists (make-array 0 :adjustable t :fill-pointer 0)))
	     (vector-push-extend (x p) (ensure-gethash (y p) x-lists (make-array 0 :adjustable t :fill-pointer 0)))
	  finally (flet ((sort-values (table)
			   (maphash #'(lambda (k v)
					(setf (gethash k table) (sort v #'<)))
				    table)))
		    (sort-values y-lists)
		    (sort-values x-lists)))

    (flet ((contains-rectangle (p0 p1)
	     (let ((x-min (1+ (min (x p0) (x p1))))
		   (x-max (1- (max (x p0) (x p1))))
		   (y-min (1+ (min (y p0) (y p1))))
		   (y-max (1- (max (y p0) (y p1)))))
	       (if (or (not (= (binary-search (gethash x-min y-lists) y-min)
			       (binary-search (gethash x-min y-lists) y-max)))
		       (not (= (binary-search (gethash x-max y-lists) y-min)
			       (binary-search (gethash x-max y-lists) y-max)))
		       (not (= (binary-search (gethash y-min x-lists) x-min)
			       (binary-search (gethash y-min x-lists) x-max)))
		       (not (= (binary-search (gethash y-max x-lists) x-min)
			       (binary-search (gethash y-max x-lists) x-max))))
		   nil
		   t))))
      (loop for (area . list-points) across *sorted-red-pairs*
	    do (if (contains-rectangle (first list-points) (second list-points))
		   (return (cons area list-points)))
	    finally (return nil)))))
	
(defun part-2 ()
  (car (loaded-data "09" #'solve-2)))
