(declaim (optimize (debug 3)))

(defpackage :day-09
  (:use #:cl)
  (:import-from :utils #:read-day-file)
  (:import-from :alexandria #:curry #:rcurry #:hash-table-keys)
  (:export #:part-1 #:part-2))

(in-package :day-09)

(defstruct (point (:conc-name nil))
  (x 0 :type fixnum)
  (y 0 :type fixnum))

(defstruct shape
  (area 0 :type fixnum))

(defstruct (v-line (:include shape))
  (x 0 :type fixnum)
  (top 0 :type fixnum)
  (bottom 0 :type fixnum))

(defstruct (h-line (:include shape))
  (y 0 :type fixnum)
  (left 0 :type fixnum)
  (right 0 :type fixnum))

(defstruct (rectangle (:include shape))
  (left nil :type v-line)
  (right nil :type v-line)
  (top nil :type h-line)
  (bottom nil :type h-line))

(defun new-rectangle (p1 p2)
  (let* ((left-x (min (x p1) (x p2)))
	 (right-x (max (x p1) (x p2)))
	 (top-y (min (y p1) (y p2)))
	 (bottom-y (max (y p1) (y p2)))
	 (left (make-v-line :x left-x :top top-y :bottom bottom-y :area (1+ (- bottom-y top-y))))
	 (right (make-v-line :x right-x :top top-y :bottom bottom-y :area (1+ (- bottom-y top-y))))
	 (top (make-h-line :y top-y :left left-x :right right-x :area (1+ (- right-x left-x))))
	 (bottom (make-h-line :y bottom-y :left left-x :right right-x :area (1+ (- right-x left-x)))))
    (make-rectangle :left left :right right :top top :bottom bottom :area (* (shape-area left) (shape-area top)))))

(defun make-shape (p1 p2)
  (cond ((= (x p1) (x p2))
	 (let ((top (min (y p1) (y p2)))
	       (bottom (max (y p1) (y p2))))
	   (make-v-line :x (x p1) :top top :bottom bottom :area (1+ (- bottom top)))))
	((= (y p1) (y p2))
	 (let ((left (min (x p1) (x p2)))
	       (right (max (x p1) (x p2))))
	   (make-h-line :y (y p1) :left left :right right :area (1+ (- right left)))))
	(t
	 (new-rectangle p1 p2))))

(defun load-data (day)
  (flet ((transform (s)
	   (let ((lst (read-from-string (concatenate 'string "(" (substitute #\Space #\, s) ")"))))
	     (make-point :x (car lst) :y (cadr lst)))))
    (mapcar #'transform (read-day-file day))))

(defun make-shapes (points)
  (loop with vec = (make-array 0 :adjustable t :fill-pointer 0)
	for sub on points
	do (if (rest sub)
	       (loop with p1 = (first sub)
		     for p2 in (rest sub)
		     do (vector-push-extend (make-shape p1 p2) vec)))
	finally (return (sort vec #'> :key #'shape-area))))

(defun part-1 ()
  (let ((shapes (make-shapes (load-data "09"))))
    (shape-area (aref shapes 0))))

(defun categorize (shapes)
  (values (sort (remove-if-not (rcurry #'typep 'h-line) shapes) #'< :key #'h-line-y)
	  (sort (remove-if-not (rcurry #'typep 'v-line) shapes) #'< :key #'v-line-x)
	  (remove-if-not (rcurry #'typep 'rectangle) shapes)))

(defun has-h-cuts (rect h-lines)
  (let ((top-pos (position-if #'(lambda (h-line)
				  (< (h-line-y (rectangle-top rect)) (h-line-y h-line) (h-line-y (rectangle-bottom rect))))
			      h-lines)))
    (if (not top-pos)
	(return-from has-h-cuts nil))
    (let ((bottom-pos (position-if #'(lambda (h-line)
				       (< (h-line-y (rectangle-top rect)) (h-line-y h-line) (h-line-y (rectangle-bottom rect))))
				   h-lines :from-end t)))
      (if (not bottom-pos)
	  (return-from has-h-cuts nil))
      (loop for pos from top-pos to bottom-pos
	    do (let ((h-line (aref h-lines pos)))
		 (if (and (< (h-line-left h-line) (v-line-x (rectangle-right rect)))
			  (< (v-line-x (rectangle-left rect)) (h-line-right h-line)))
		     (return t)))
	    finally (return nil)))))

(defun has-v-cuts (rect v-lines)
  (let ((left-pos (position-if #'(lambda (v-line)
				   (< (v-line-x (rectangle-left rect)) (v-line-x v-line) (v-line-x (rectangle-right rect))))
			      v-lines)))
    (if (not left-pos)
	(return-from has-v-cuts nil))
    (let ((right-pos (position-if #'(lambda (v-line)
				       (< (v-line-x (rectangle-left rect)) (v-line-x v-line) (v-line-x (rectangle-right rect))))
				   v-lines :from-end t)))
      (if (not right-pos)
	  (return-from has-v-cuts nil))
      (loop for pos from left-pos to right-pos
	    do (let ((v-line (aref v-lines pos)))
		 (if (and (< (v-line-top v-line) (h-line-y (rectangle-bottom rect)))
			  (< (h-line-y (rectangle-top rect)) (v-line-bottom v-line)))
		     (return t)))
	    finally (return nil)))))

(defun inside-polygon (x y v-lines)
  (oddp (count-if #'(lambda (v)
		      (and (< x (v-line-x v))
			   (<= (v-line-top v) y (v-line-bottom v))))
		  v-lines)))

(defun v-line-in-polygon (v-line v-lines)
  (let ((to-test (remove-if-not #'(lambda (v) (<= (v-line-x v-line) (v-line-x v))) v-lines)))
    (loop for y from (v-line-top v-line) to (v-line-bottom v-line)
	  do (if (not (or (find-if #'(lambda (v)
				       (and (= (v-line-x v-line) (v-line-x v))
					    (<= (v-line-top v) y (v-line-bottom v))))
				   to-test)
			  (inside-polygon (v-line-x v-line) y to-test)))
		 (return nil))
	  finally (return t))))

(defun h-line-in-polygon (h-line h-lines v-lines)
  (let ((colinear (remove-if-not #'(lambda (h) (= (h-line-y h-line) (h-line-y h))) h-lines)))
    (loop for x from (h-line-left h-line) to (h-line-right h-line)
	  do (if (not (or (find-if #'(lambda (h)
				       (<= (h-line-left h) x (h-line-right h)))
				   colinear)
			  (inside-polygon x (h-line-y h-line) v-lines)))
		 (return nil))
	  finally (return t))))

(defun sample-in-polygon (times v-lines rect)
  (let ((min-x (v-line-x (rectangle-left rect)))
	(max-x (v-line-x (rectangle-right rect)))
	(min-y (h-line-y (rectangle-top rect)))
	(max-y (h-line-y (rectangle-bottom rect))))
    (dotimes (test times)
      (let ((x (+ min-x (random (- (1+ max-x) min-x))))
	    (y (+ min-y (random (- (1+ max-y) min-y)))))
	(if (not (inside-polygon x y v-lines))
	    (return-from sample-in-polygon nil))))
    t))
    
(defun part-2 ()
  (let ((shapes (make-shapes (load-data "09a"))))
    (multiple-value-bind (h-lines v-lines rectangles) (categorize shapes)
      (find-if (curry #'sample-in-polygon 200 v-lines) rectangles))))
		   
  #|(let ((shapes (make-shapes (load-data "09a"))))
    (multiple-value-bind (h-lines v-lines rectangles) (categorize shapes)
      (find-if #'(lambda (rect)
		   (and (not (has-h-cuts rect h-lines))
			(not (has-v-cuts rect v-lines))
			(v-line-in-polygon (rectangle-left rect) v-lines)
			(v-line-in-polygon (rectangle-right rect) v-lines)
			(h-line-in-polygon (rectangle-top rect) h-lines v-lines)
			(h-line-in-polygon (rectangle-bottom rect) h-lines v-lines)))
	       shapes))))
|#
#|      (loop for rect across rectangles
	    do (let ((h-cuts (has-h-cuts rect h-lines))
		     (v-cuts (has-v-cuts rect v-lines))
		     (left-in (v-line-in-polygon (rectangle-left rect) v-lines))
		     (right-in (v-line-in-polygon (rectangle-right rect) v-lines))
		     (top-in (h-line-in-polygon (rectangle-top rect) h-lines v-lines))
		     (bottom-in (h-line-in-polygon (rectangle-bottom rect) h-lines v-lines)))
		 (format t "~A h-cuts: ~A v-cuts: ~A l-in ~A r-in ~A t-in ~A b-in ~A~%" rect h-cuts v-cuts left-in right-in top-in bottom-in))))))
|#
